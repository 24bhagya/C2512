****************1.What is virtual function and pure virtual function.?******************************


virtual function:  `Virtual functions` allow a function to be overridden in a derived class.
The function is called based on the actual object type at runtime, not the pointer type.

- `Virtual` function allows runtime polymorphism.
- It must be defined with the `virtual` keyword in the base class.

`Example:`
```cpp
class Base {
public:
    virtual void show() {
        std::cout << "Base class show" << std::endl;
    }
};

class Derived : public Base {
public:
    void show() override {
        std::cout << "Derived class show" << std::endl;
    }
};
```
***********What is a Pure Virtual Function?
        Pure virtual function is a function that is declared in a base class but does not have a body (i.e., no implementation).
        It is meant to be overridden (redefined) by derived classes.
        A pure virtual function makes the class abstract, meaning the base class cannot be instantiated on its own.

eg:

        class Base {
        public:
            virtual void function() = 0;  // Pure virtual function
        };

***************************3.Why do we need run time polymorphism. *********************************************************
   - This type of polymorphism is resolved at runtime, 
   usually when the exact method to be called is determined 
   based on the object type at runtime.
   - It is achieved through `method overriding` 
   (inheritance) and `virtual functions`.
   - It is commonly used with base class pointers or references 
   that point to derived class objects.

why we need?
    We need runtime polymorphism because it:

    -Provides flexibility to work with different object types using a common interface.
    -Increases reusability and modularity.
    -Makes code more extensible without changing existing code.
    -Helps in managing multiple objects of different types in a uniform way.

***************************4..Difference between compile time polymorphism and run time polymorphism.***********************************************


| **Feature**                    | **Compile-time Polymorphism**                              | **Run-time Polymorphism**                                      |
|---------------------------------|------------------------------------------------------------|---------------------------------------------------------------|
| **Resolution Time**             | Call is resolved by the compiler.                          | Call is not resolved by the compiler.                          |
| **Also Known As**               | Static binding or Early binding or Overloading.            | Dynamic binding or Late binding or Overriding.                 |
| **Method Selection**            | Overloading: Multiple methods share the same name with different parameters. | Overriding: Same method name with same parameters in different classes. |
| **Achieved By**                 | Function overloading and operator overloading.             | Virtual functions and pointers.                                |
| **Performance**                 | Provides fast execution because known early at compile time. | Provides slow execution as compared to compile-time because it resolves at runtime. |
| **Flexibility**                 | Less flexible as everything is resolved at compile time.   | More flexible as everything is resolved at runtime.            |


*************************5.How pointer works:***********************************************************************

allows you to store the memory address of a variable rather than the actual value. 

A pointer is a variable that stores the memory address of another variable. 
Instead of holding a direct value like an integer or a character, it holds the address where that value is stored in memory.

    type* pointerName;

eg:
    int num = 10;
    int* ptr = &num;  // Pointer to an integer, stores address of num
Explanation:
    num is a regular integer variable that stores the value 10.
    ptr is a pointer that stores the address of num.
    &num is the address-of operator. It returns the memory address of the variable num.


***********************6. difference between **Static Memory Allocation** and **Dynamic Memory Allocation**:*********************************************************

| **Feature**                     | **Static Memory Allocation**                                   | **Dynamic Memory Allocation**                             |
|----------------------------------|-------------------------------------------------------        |-----------------------------------------------------------|
| **Memory Allocation Time**      | Memory is allocated at **compile time**.                       | Memory is allocated at **runtime**.                       |
| **Memory Size**                 | The size of memory must be known before program execution.     | The size of memory can be determined during program execution. |
| **Memory Management**           | Managed automatically by the system (stack memory).            | Managed manually by the programmer (heap memory).         |
| **Flexibility**                 | Less flexible; memory size cannot be changed during runtime.   | More flexible; memory can be allocated and resized during runtime. |
| **Types of Allocation**         | For fixed-size variables and arrays.                           | For variables and arrays whose size can vary.             |
| **Use Case**                    | Suitable for small, fixed-size arrays and variables.           | Suitable for large arrays, objects, and data structures that need flexible memory. |
| **Memory Deallocation**         | Automatically deallocated when the variable goes out of scope. | Must be manually deallocated using `delete` or `delete[]`. |
| **Efficiency**                  | Faster and more efficient as allocation is done at compile time | Slower compared to static allocation due to runtime allocation. |
| **Example**                     | `int arr[10];`                                                  | `int* arr = new int[10];`                                  |
| **Risk of Memory Issues**       | No risk of memory leaks or dangling pointers.                   | Potential for memory leaks or dangling pointers if not managed properly. |


***nnew and delete syntax:
new :
 type* pointer = new type;
delete:
 delete pointer;

**************7.What happens if delete is not done?**********************************************

After using delete, the pointer still holds the address of the memory that has been freed, which can lead to accessing invalid memory.
Always set the pointer to nullptr after deletion to avoid accidental access

delete ptr;
ptr = nullptr;  // Pointer is now safe

*********************8.memory leak:*******************************

A memory leak occurs when a program allocates memory dynamically (using new or malloc()), but fails to release it (using delete or free()) when it is no longer needed.
Over time, as the program continues to run, these leaks accumulate and may eventually lead to performance degradation or the program crashing due to lack of available memory.

************************9.structure and union:******************************************


```
+-----------------------+---------------------------------------------+---------------------------------------------+
|      Feature          |                Structure                    |                  Union                     |
+-----------------------+---------------------------------------------+---------------------------------------------+
| Memory Allocation     | Each member has its own memory location.    | All members share the same memory location. |
+-----------------------+---------------------------------------------+---------------------------------------------+
| Memory Size           | The total size is the sum of the sizes of   | The size is equal to the size of the        |
|                       | all members.                                | largest member.                             |
+-----------------------+---------------------------------------------+---------------------------------------------+
| Usage                 | Stores multiple values at the same time.    | Stores only one value at a time.            |
+-----------------------+---------------------------------------------+---------------------------------------------+
| Size Calculation      | Size is the sum of all member sizes         | Size is determined by the size of the       |
|                       | (including padding).                        | largest member.                             |
+-----------------------+---------------------------------------------+---------------------------------------------+
| Accessing Members     | All members can be accessed independently.  | Only one member can be accessed at a time  |
|                       |                                             | (the last assigned).                        |
+-----------------------+---------------------------------------------+---------------------------------------------+
| Purpose               | When you need to store different types of   | When you need to store different types of   |
|                       | data together.                              | data but only use one at a time.            |
+-----------------------+---------------------------------------------+---------------------------------------------+
```

**********************
10.how compiler works:***********************************************

    Source Code → (Preprocessor) → Preprocessed Code
    Preprocessed Code → (Compiler) → Assembly Code
    Assembly Code → (Assembler) → Object Code
    Object Code + Libraries → (Linker) → Executable
    Executable → (Loader) → Running Program

**************11. Find a particular word in a string and replace it with another word.**********************

#include <iostream>
#include <string>
using namespace std;

int main() {
    string sentence = "Hello world! Welcome to the world of programming.";
    string wordToReplace = "world";
    string newWord = "universe";

    // Find the position of the word to replace
    size_t pos = sentence.find(wordToReplace);

    // Replace the word if found
    while (pos != string::npos) {
        sentence.replace(pos, wordToReplace.length(), newWord);
        pos = sentence.find(wordToReplace, pos + newWord.length());
    }

    cout << "Updated sentence: " << sentence << endl;

    return 0;
}

**************12.difference between class and struct*******************

- By default, all members of a structure are public, while all members of a class are private.
- Classes are used for more complex object-oriented programming with features like encapsulation and inheritance, whereas structures are typically used for simpler data groupings.
- Classes generally encapsulate data and functionality together, while structures usually just store data (although in modern C++, both can have methods).

**********************13.Pointers in C++*****************************

    A pointer is a variable that stores the memory address of another variable.
    Rather than holding a direct value like an integer or character, a pointer holds the location in memory where that value is stored.
    Pointers are a crucial concept in C++ because they allow for efficient memory management, dynamic memory allocation, and the ability to directly manipulate memory.

****************14.Abstract Class:**********************************

    An abstract class is a class that cannot be instantiated on its own. 
    It is used as a base class for other classes. The primary purpose of an abstract class is to provide a common interface (or blueprint) for derived classes.
    
    Key Features of Abstract Classes:
    It can contain pure virtual functions (which must be implemented in derived classes).
    It may have regular functions that are implemented.
    An abstract class is meant to be inherited by other classes, not instantiated directly.

*************15.Explain memory allocation of pointers.********************

In C++, pointers are used to store the memory addresses of variables.

Memory Allocation Types for Pointers:
   - Static Memory Allocation (Compile-time allocation)
   - Dynamic Memory Allocation (Runtime allocation)
1. Static Memory Allocation:
   - In static memory allocation, memory for a variable is allocated at compile time, and the size of the memory is fixed.
   - In case of pointers, the pointer itself is stored in the stack memory, and it points to some statically allocated memory (such as local variables).

code eg:

    int a = 10;      // Memory for 'a' is statically allocated in the stack.
    int* ptr = &a;   // Pointer 'ptr' holds the address of 'a'.

 2.Dynamic Memory Allocation:
    
    - In dynamic memory allocation, memory is allocated at runtime using special functions like new or malloc. 
    - The memory is allocated from the heap (also known as free store). 
    - Dynamic memory allocation is flexible because the amount of memory needed can be decided while the program is running, based on user input or other conditions.   

code eg:
    int* ptr = new int;    // Allocating memory for one integer on the heap
    *ptr = 10;             // Assigning value 10 to the allocated memory
    
    cout << *ptr << endl;  // Output: 10
    
    delete ptr;            // Deallocating the dynamically allocated memory

**************16.Array of pointers:**************

 -   An array of pointers is an array where each element is a pointer that stores the memory address of a variable.
 -  Instead of storing actual values, it stores addresses of other variables or objects.

**************17.inheritance in c++?***************

    - Inheritance is one of the core concepts of Object-Oriented Programming (OOP). 
    - It allows one class to inherit properties (variables) and behaviors (functions) from another class. 
    - This helps in reusing code, making programs more modular and easier to maintain.

In inheritance:

The base class (or parent class) is the class being inherited from.
The derived class (or child class) is the class that inherits the properties and behaviors.

Types of Inheritance:

    Single Inheritance: A derived class inherits from one base class.
    Multiple Inheritance: A derived class inherits from more than one base class.
    Multilevel Inheritance: A class is derived from another derived class.
    Hierarchical Inheritance: Multiple classes inherit from a single base class.

Example of Inheritance:
Let’s consider a base class called Animal and a derived class called Dog that inherits from Animal.

#include <iostream>
using namespace std;

// Base class
class Animal {
public:
    void eat() {  // Common method for all animals
        cout << "Animal is eating." << endl;
    }
};

// Derived class
class Dog : public Animal {  // Dog inherits from Animal
public:
    void bark() {  // Specific to Dog
        cout << "Dog is barking." << endl;
    }
};

int main() {
    Dog dog;  // Create object of derived class
    
    dog.eat();  // Inherited from Animal
    dog.bark(); // Specific to Dog
    
    return 0;
}
    
Explanation:
    Animal Class: This is the base class that has a method eat(), which is common to all animals.
    Dog Class: This is the derived class that inherits from Animal. It can access the eat() method from Animal and also has its own method bark().
    In Main():
    We create an object dog of type Dog.
    The dog object can use both methods: eat() (inherited from Animal) and bark() (specific to Dog).

***************18.Do a real life program to show inheritance (Parent class Suzuki, subclasses Swift, Alto)
    -Use method override 
    -Use dynamic memory allocation *********************************

#include <iostream>
#include <string>
using namespace std;

// Base class: Suzuki
class Suzuki {
public:
    // Virtual function to allow method overriding
    virtual void startCar() {
        cout << "Starting a Suzuki car..." << endl;
    }

    virtual ~Suzuki() {} // Virtual Destructor for proper cleanup
};

// Derived class: Swift
class Swift : public Suzuki {
public:
    // Overriding startCar function
    void startCar() override {
        cout << "Starting the Suzuki Swift..." << endl;
    }
};

// Derived class: Alto
class Alto : public Suzuki {
public:
    // Overriding startCar function
    void startCar() override {
        cout << "Starting the Suzuki Alto..." << endl;
    }
};

int main() {
    // Dynamic memory allocation for Suzuki cars
    Suzuki* suzukiCar; // Base class pointer

    // Dynamically allocate a Swift object
    suzukiCar = new Swift(); 
    suzukiCar->startCar();  // Calls Swift's version of startCar

    // Dynamically allocate an Alto object
    suzukiCar = new Alto(); 
    suzukiCar->startCar();  // Calls Alto's version of startCar

    // Free dynamically allocated memory
    delete suzukiCar;

    return 0;
}


Explanation of the Code:

- Base Class: Suzuki:

This class represents a general Suzuki car and has a virtual method startCar(). The virtual keyword allows derived classes to override this method and provide their specific behavior.
A virtual destructor is included to ensure proper memory cleanup when deleting objects of derived classes.
Derived Class: Swift:

Swift is a subclass of Suzuki and overrides the startCar() method to provide its own implementation (printing a message specific to the Swift model).

- Derived Class: Alto:

Similar to Swift, the Alto class also overrides the startCar() method to give a different message for starting an Alto car.

- Dynamic Memory Allocation:

The base class pointer Suzuki* suzukiCar is used to point to objects of Swift and Alto.
new is used to dynamically allocate memory for Swift and Alto objects, and the appropriate startCar() method is called depending on the actual type of the object (thanks to runtime polymorphism).

- Deleting Dynamically Allocated Memory:

The delete keyword is used to free the dynamically allocated memory. This ensures that the destructors are properly called, and memory is cleaned up when the program ends.

**********19.malloc and calloc:**************

1. **Purpose**:  
   - `malloc` allocates a specified amount of memory.
   - `calloc` allocates memory for an array of elements and initializes it to zero.

2. **Syntax**:  
   - `malloc` uses: `void* malloc(size_t size);`
   - `calloc` uses: `void* calloc(size_t num, size_t size);`

3. **Initialization**:  
   - `malloc` does not initialize the allocated memory (values are undefined).
   - `calloc` initializes the allocated memory to zero.

4. **Return Value**:  
   - Both return a pointer to the allocated memory or `NULL` if the allocation fails.

5. **Use Case**:  
   - `malloc` is used when you only need memory allocation and don't need initialization.
   - `calloc` is used when you need both memory allocation and initialization (to zero).

6. **Example**:  
   - `malloc` example: `int* ptr = (int*) malloc(5 * sizeof(int));`
   - `calloc` example: `int* ptr = (int*) calloc(5, sizeof(int));`


***********20.Program to Find Average of n Even Numbers (Modified Condition):*************

#include <iostream>
using namespace std;

int main() {
    int n, sum = 0, count = 0;

    // Taking input for the number of even numbers to consider
    cout << "Enter the number of even numbers: ";
    cin >> n;

    // Loop to find and add even numbers to sum
    for (int i = 0; count < n; i++) {
        if (i % 2 == 0) { // This is the original condition
            sum += i;
            count++;
        }
    }

    // Calculating and printing the average
    float average = (float)sum / n;
    cout << "The average of first " << n << " even numbers is: " << average << endl;

    return 0;
}


Modified Program Using a Different Condition:

#include <iostream>
using namespace std;

int main() {
    int n, sum = 0;

    // Taking input for the number of even numbers to consider
    cout << "Enter the number of even numbers: ";
    cin >> n;

    // Loop to find and add even numbers to sum, directly increasing i by 2
    for (int i = 0; n > 0; i += 2) { // i is incremented by 2 directly to get even numbers
        sum += i;
        n--;
    }

    // Calculating and printing the average
    float average = (float)sum / n;
    cout << "The average of the first " << n << " even numbers is: " << average << endl;

    return 0;
}

************21.run time polymorphism code example******************

#include <iostream>
using namespace std;

// Base class
class Shape {
public:
    virtual int findArea() = 0; // Pure virtual function
};

// Derived class for Rectangle
class Rectangle : public Shape {
public:
    int length;
    int breadth;
    
    Rectangle(int length1, int breadth1) : length(length1), breadth(breadth1) {}

    int findArea() override {
        return (length * breadth); // Area of rectangle
    }
};

// Derived class for Triangle
class Triangle : public Shape {
public:
    int base;
    int height;

    Triangle(int base1, int height1) : base(base1), height(height1) {}

    int findArea() override {
        return (base * height) / 2; // Area of triangle
    }
};

// Derived class for Square
class Square : public Shape {
public:
    int side;

    Square(int side1) : side(side1) {}

    int findArea() override {
        return (side * side); // Area of square
    }
};

int main() {
    // Creating objects of derived classes
    Rectangle R1(10, 20);
    Triangle T1(5, 10);
    Square S1(5);
    
    // Base class pointer to demonstrate run-time polymorphism
    Shape* shapePtr;
    
    shapePtr = &R1;
    cout << "Area of Rectangle: " << shapePtr->findArea() << endl;

    shapePtr = &T1;
    cout << "Area of Triangle: " << shapePtr->findArea() << endl;

    shapePtr = &S1;
    cout << "Area of Square: " << shapePtr->findArea() << endl;

    return 0;
}


*********22.Difference between built-in datatypes and user defined datatypes. *******************

| Aspect                     | Built-in Data Types                                         | User-defined Data Types                 
|----------------------------|-------------------------------------------------------------|------------------------------------------
| Definition                 | Predefined in C++ and directly supported by the language.   | Created by the programmer to suit specific needs. 
| Examples                   | int, float, char, double, bool, etc.                        | struct, class, union, enum, etc.         
| Size                       | Fixed size determined by the system/compiler.               | Size depends on the definition.          
| Memory Allocation          | Automatically allocated based on the type.                  | Manually allocated based on design.     
| Usage                      | Used for simple data like numbers, characters.              | Used for creating complex structures grouping different data types. 
| Flexibility                | Less flexible, predefined structures.                       | More flexible, can define custom structures. 
| Example                    | int x = 5; (integer), float y = 5.5; (float)                | struct Person { string name; int age; }; 

************23.What is a Class?

A class is like a recipe or a template that tells the computer how to create and handle something. For example, think of a class as a blueprint for a car. 
The class tells the computer how to make a car with wheels, doors, and an engine, but it doesn't make a car itself. 
To make a car, you create an object using that blueprint.

Advantages of Using a Class:

Organization: A class groups similar data and actions together.
Reuse: We can use the same class to create multiple objects with different details (like different car models).
Maintenance: If something needs to change, we can make the change in the class, and it will apply to all objects created from it.

**23.Which phase is the most time-consuming in the Software Development Life Cycle (SDLC)?

The most time-consuming phase in the Software Development Life Cycle (SDLC) is typically the maintenance phase.

Maintenance Phase: After a software product is deployed, it requires continuous updates, bug fixes, performance improvements, and changes due to evolving user needs or external factors (like updates to underlying technologies or frameworks). This phase can last for years and involves:
Addressing issues that arise in production.
Implementing new features or enhancements.
Fixing bugs and performance optimizations.
Ensuring compatibility with new operating systems or other software.

**24.What is the difference between int a = 10; and int a(10); 

int a = 10; (Copy Initialization)
Explanation: This is known as copy initialization. Here, the value 10 is assigned to the variable a.
Behavior: The value 10 is directly assigned to a. It uses the assignment operator (=) for initialization.

Example:

int a = 10;  // Copy initialization

2. int a(10); (Direct Initialization)
Explanation: This is known as direct initialization. Here, the value 10 is passed directly to the constructor of the type (in this case, the int type).
Behavior: The value 10 is passed to the constructor, and a is initialized with that value.

Example:

int a(10);  // Direct initialization


**25.program to reverse a string:

#include <iostream>
#include <string>
using namespace std;

int main() {
    string str;

    // Input the string
    cout << "Enter a string: ";
    getline(cin, str);

    // Reverse the string using a loop
    int start = 0;
    int end = str.length() - 1;

    while (start < end) {
        // Swap the characters at start and end
        swap(str[start], str[end]);

        // Move the start forward and the end backward
        start++;
        end--;
    }

    // Output the reversed string
    cout << "Reversed string: " << str << endl;

    return 0;
}


**26.Code to pass a value to a function by pass bypointer method.

#include <iostream>
using namespace std;

// Function to change the value using pointer
void changeValue(int* ptr) {
    *ptr = 20;  // Dereferencing the pointer and modifying the value
}

int main() {
    int num = 10;

    cout << "Before change: " << num << endl;

    // Passing the address of num (pointer) to the function
    changeValue(&num);

    cout << "After change: " << num << endl;

    return 0;
}


**27.Allocate dynamic memory to an integer variable using new

#include <iostream>
using namespace std;

int main() {
    // Dynamically allocate memory for an integer
    int* ptr = new int;  // 'ptr' is a pointer to an integer

    // Assign a value to the dynamically allocated memory
    *ptr = 25;

    // Output the value stored in the dynamically allocated memory
    cout << "Value: " << *ptr << endl;

    // Deallocate the memory once it is no longer needed
    delete ptr;

    return 0;
}


**28.Logic of code to find whether a string is palindromeor not .

// C++ program to check whether the given string
// is palindrome or not using reverse() function
#include <bits/stdc++.h>
using namespace std;

void isPalindrome(string str) {
  
      // Stores the reverse of the string s
    string rev = str;

    // Reverse the string
    reverse(rev.begin(), rev.end());

    // If rev is equal to str
    if (str == rev)
        cout << "\"" << str
          << "\" is palindrome." << endl;
      
    // If rev is NOT equal to str
    else
        cout << "\"" << str
          << "\" is NOT palindrome." << endl;
}

int main() {
    
      // Checking if strings given strings are palindrome
    isPalindrome("ABCDCBA");
      isPalindrome("ABCD");

    return 0;
}

**29.constructors:

A constructor is a special member function in a class that is automatically called when an object of the class is created. 
Its main purpose is to initialize the object, meaning it sets the initial values of the data members of the class.

class Vehicle {
public:
    // Base class constructor
    Vehicle(int s) {
        cout << "Vehicle speed: " << s << " km/h" << endl;
    }
};

30.fibonocci series:

#include <iostream>
using namespace std;

void fibonacci(int n) {
    int a = 0, b = 1, c;
    if (n >= 1) cout << a << " ";  // Print first term (0)
    if (n >= 2) cout << b << " ";  // Print second term (1)
    
    for (int i = 3; i <= n; i++) {
        c = a + b;  // Next term is the sum of the previous two
        cout << c << " ";  // Print the next term
        a = b;  // Update a to the previous term
        b = c;  // Update b to the current term
    }
    cout << endl;
}

int main() {
    int n;
    cout << "Enter the number of terms: ";
    cin >> n;
    
    cout << "Fibonacci Series: ";
    fibonacci(n);
    
    return 0;
}


31.What is an EXE?

An EXE (Executable) file is a type of file that contains a program or software application that can be run on a computer. 
When you double-click an EXE file, it starts an application or a process in the operating system.
EXE files contain machine code or instructions that tell the computer what to do, such as opening a program, performing tasks, or interacting with hardware.

File extension: .exe
Purpose: Used to launch programs or applications on Windows operating systems.
Example: notepad.exe, chrome.exe

32.What is a DLL?
A DLL (Dynamic Link Library) file is a type of file that contains a collection of functions and data that can be used by multiple programs simultaneously. 
Instead of writing the same code multiple times in different programs, DLL files allow applications to use the code in the DLL, promoting modular programming, saving memory, and enhancing reusability. 
DLL files do not run on their own; they are called and used by EXE files or other DLLs.

33.prime number code:

#include <iostream>
using namespace std;

bool isPrime(int num) {
    if (num <= 1) return false; // Numbers less than or equal to 1 are not prime
    for (int i = 2; i * i <= num; i++) { // Check divisors up to the square root of num
        if (num % i == 0) return false; // If divisible, it's not a prime
    }
    return true; // If no divisors found, it's a prime
}

int main() {
    int number;
    cout << "Enter a number: ";
    cin >> number;

    if (isPrime(number)) {
        cout << number << " is a prime number." << endl;
    } else {
        cout << number << " is not a prime number." << endl;
    }

    return 0;
}

34.friend function:

A friend function is a non-member function that can access private and protected members of a class.
It is declared in the class using the keyword friend.
It is used when an external function needs access to a class’s private or protected data.
It is not bound to any specific object and can access data from any object of the class.
Syntax is friend <return_type> <function_name>(<parameters>);.
Example:

class Box {
    private:
        int length;

    public:
        Box(int len) : length(len) {}
        friend void printLength(Box b); // Friend function declaration
};

void printLength(Box b) { // Friend function definition
    cout << "Length: " << b.length << endl;
}


35.static variable

A static variable retains its value between function calls and is allocated in the data segment of memory.
It exists throughout the program’s lifetime but is limited in scope to the block where it is declared.
Static variables are useful to keep track of data across function calls.
Example:

void counter() {
    static int count = 0; // Static variable retains its value
    count++;
    cout << "Count: " << count << endl;
}

36.static function:

A static function belongs to the class, not to any specific object.
It can access only static members of the class and is useful for utility functions.
Static functions are called using ClassName::FunctionName();.
Example:

class Calculator {
    public:
        static int add(int a, int b) {
            return a + b;
        }
};
cout << "Sum: " << Calculator::add(5, 3) << endl; // Calling static function




37.### 1. **Reverse a String Using Recursion**  
```cpp
#include <iostream>
using namespace std;

void reverseString(string str, int index) {
    if (index < 0) {
        return;
    }
    cout << str[index];
    reverseString(str, index - 1);
}

int main() {
    string str = "hello";
    cout << "Original String: " << str << endl;
    cout << "Reversed String: ";
    reverseString(str, str.length() - 1);
    cout << endl;
    return 0;
}
```

---

### 2. **Swap Two Numbers Without Using a Temporary Variable**  
```cpp
#include <iostream>
using namespace std;

int main() {
    int a = 5, b = 10;
    cout << "Before Swap: a = " << a << ", b = " << b << endl;

    a = a + b; // a becomes 15
    b = a - b; // b becomes 5
    a = a - b; // a becomes 10

    cout << "After Swap: a = " << a << ", b = " << b << endl;
    return 0;
}
```

---

### 3. **Sorting (Bubble Sort)**  
```cpp
#include <iostream>
using namespace std;

void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // Swap without temporary variable
                arr[j] = arr[j] + arr[j + 1];
                arr[j + 1] = arr[j] - arr[j + 1];
                arr[j] = arr[j] - arr[j + 1];
            }
        }
    }
}

int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr) / sizeof(arr[0]);

    cout << "Original array: ";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;

    bubbleSort(arr, n);

    cout << "Sorted array: ";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;

    return 0;
}
```

38.









